Windows下的托盘(tray)是不是很酷呢？利用这种机制，你可以方便的把自己的应用程序嵌入到任务栏里。
大多数时候，应用程序在后台工作，不会干扰用户，当用户想查看某些信息时，只点一下这个小图标就行
了。应用程序在响应点击事件时，可以把应用程序提到前台来，可以弹出一个对话框，可以显示一个菜单，
或者做其它任何事情，这完全是应用程序自己的事，与任务栏一点关系都没有。

在Linux下的桌面环境里，不但有这个功能，而且功能更加强大。Linux下的桌面环境有好几种，在PC上最
为流行的当然是KDE和GNOME。它们往往都有一套自己的机制，搞得不同桌面环境下开发的应用程序之间的
兼容性很差。为了让这些应用程序之间能够互相嵌入，当然得有一个标准才行。为此，freedesktop.org组
织制定了一个XEBEDDED协议(http://www.freedesktop.org/wiki/Standards_2fxembed_2dspec)。

只要遵守XEBEDDED协议，用Qt写的应用程序可以嵌入到GNOME的任务栏里，用GTK+写的应用程序可以嵌入到
KDE的任务栏里。不但如此，在需要的情况下，两个应用程序之间也可以任意嵌入，而不必关心它们是用哪
个库实现的。

虽然说这个协议很简单，自己要从头实现一个，未免太麻烦了。为了简化应用程序开发，GTK+已经封装一套
函数。本文用一个简单的实例，介绍如何开发这类应用。在此之前，我们先熟悉几个概念：

插座(socket)：这里指宿主窗口，它可以让其它应用程序，把窗口嵌入到它里面。如，任务栏就是一个插座
              (socket)。

插头(plug):顾名思义，它就是被嵌入的窗口，可以插入到插座(socket)上。相对任务栏而言，应用程序的窗
		   口就是插头(plug)。

插头(plug)/插座(socket)两者可以在同一个应用中，也可以在不同的应用程序中。在同一个应用程序里，这
种做法意义不大，而且可以说是自找麻烦。大多数情况下，它们分别位于不同的进程之中，一个插座(socket)
窗口可以容纳多个插头(plug)窗口中，而一个插头(plug)窗口只能处于一个插座(socket)窗口之中。

程序执行方法，先运行socket，这样会一个socket_id, 然后运行plugsocket_id,这样plug就会显示到plug中
